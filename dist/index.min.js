"use strict";var StaticVault=(()=>{var x=Object.defineProperty;var I=Object.getOwnPropertyDescriptor;var E=Object.getOwnPropertyNames;var M=Object.prototype.hasOwnProperty;var V=(s,t)=>{for(var e in t)x(s,e,{get:t[e],enumerable:!0})},$=(s,t,e,r)=>{if(t&&typeof t=="object"||typeof t=="function")for(let i of E(t))!M.call(s,i)&&i!==e&&x(s,i,{get:()=>t[i],enumerable:!(r=I(t,i))||r.enumerable});return s};var C=s=>$(x({},"__esModule",{value:!0}),s);var K={};V(K,{BrowserFileIO:()=>S,CacheFileIO:()=>A,CryptoKey:()=>u,DirectoryFileIO:()=>b,FileIO:()=>f,MemoryFileIO:()=>P,ReadonlyFileIO:()=>U,Vault:()=>v,bytesToString:()=>y,hashBytes:()=>k,resolvePath:()=>g,stringToBytes:()=>h,stringify:()=>w});function y(s){return(typeof process<"u"?Buffer.from(s).toString("base64"):btoa(String.fromCharCode(...s))).replace(/\+/g,"-").replace(/\//g,"_").replace(/=+$/,"")}function h(s){let t=s.replace(/-/g,"+").replace(/_/g,"/");for(;t.length%4;)t+="=";return typeof process<"u"?new Uint8Array(Buffer.from(t,"base64")):new Uint8Array(atob(t).split("").map(e=>e.charCodeAt(0)))}function w(s){if(s!==null&&typeof s=="object"&&!Array.isArray(s)){let t=Object.keys(s);t.sort((r,i)=>r.localeCompare(i));let e=[];for(let r of t)e.push(`${JSON.stringify(r)}:${w(s[r])}`);return`{${e.join(",")}}`}else return JSON.stringify(s)}async function k(s){let t=await crypto.subtle.digest("SHA-256",s);return Array.from(new Uint8Array(t)).map(e=>e.toString(16).padStart(2,"0")).join("")}function g(s,t){if(!s.startsWith("/"))throw new Error("Current directory must be absolute");let e=t.startsWith("/")||s==="/"?[]:s.substr(1).split("/"),r=t.split("/");for(let i of r)i==="."||(i===".."?e.pop():i!==""&&e.push(i));return e}var u=class s{constructor(t){this.key=t}assertEqual(t){if(!t||this.key.length!==t.key.length)throw new Error("Keys not equal");for(let e=0;e<this.key.length;e++)if(this.key[e]!==t.key[e])throw new Error("Keys not equal")}static async generate(){let t=await crypto.subtle.generateKey({name:"AES-GCM",length:256},!0,["encrypt","decrypt"]),e=await crypto.subtle.exportKey("raw",t);return new s(new Uint8Array(e))}static importUnsafeRaw(t){return new s(h(t))}static async importWithPassword(t,e){let r=t.split(".");if(r.length!==4)return null;let i=parseFloat(r[3]);if(isNaN(i)||i<=0)return null;try{let[n,o,a]=r,l=await crypto.subtle.importKey("raw",new TextEncoder().encode(e),{name:"PBKDF2"},!1,["deriveKey"]),d=await crypto.subtle.deriveKey({name:"PBKDF2",salt:h(o),iterations:i*1e5,hash:"SHA-256"},l,{name:"AES-GCM",length:256},!1,["decrypt"]),c=await crypto.subtle.decrypt({name:"AES-GCM",iv:h(a)},d,h(n));return{key:new s(new Uint8Array(c)),difficulty:i}}catch{return null}}exportUnsafeRaw(){return y(this.key)}async exportWithPassword(t,e=5){let r=new TextEncoder,i=crypto.getRandomValues(new Uint8Array(16)),n=crypto.getRandomValues(new Uint8Array(12)),o=await crypto.subtle.importKey("raw",r.encode(t),{name:"PBKDF2"},!1,["deriveKey"]),a=await crypto.subtle.deriveKey({name:"PBKDF2",salt:i,iterations:e*1e5,hash:"SHA-256"},o,{name:"AES-GCM",length:256},!1,["encrypt"]),l=await crypto.subtle.encrypt({name:"AES-GCM",iv:n},a,this.key);return[y(new Uint8Array(l)),y(i),y(n),`${e}`].join(".")}async encryptString(t){let e=crypto.getRandomValues(new Uint8Array(12)),r=await crypto.subtle.importKey("raw",this.key,{name:"AES-GCM"},!1,["encrypt"]),i=await crypto.subtle.encrypt({name:"AES-GCM",iv:e},r,new TextEncoder().encode(t));return[y(new Uint8Array(i)),y(e)].join(".")}async decryptString(t){let e=t.split(".");if(e.length!==2)return null;try{let[r,i]=e,n=await crypto.subtle.importKey("raw",this.key,{name:"AES-GCM"},!1,["decrypt"]),o=await crypto.subtle.decrypt({name:"AES-GCM",iv:h(i)},n,h(r));return new TextDecoder().decode(o)}catch{return null}}async encryptObject(t){let e=await this.encryptString(w(t)),r="ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_";return r[Math.floor(Math.random()*r.length)]+e}async decryptObject(t){try{let e=await this.decryptString(t.substr(1));if(!e)return null;let r=JSON.parse(e);return r&&typeof r=="object"?r:null}catch{return null}}async encryptBytes(t){let e=crypto.getRandomValues(new Uint8Array(12)),r=await crypto.subtle.importKey("raw",this.key,{name:"AES-GCM"},!1,["encrypt"]),i=await crypto.subtle.encrypt({name:"AES-GCM",iv:e},r,t);return{encryptedBytes:new Uint8Array(i),iv:y(e)}}async decryptBytes(t,e){try{let r=await crypto.subtle.importKey("raw",this.key,{name:"AES-GCM"},!1,["decrypt"]),i=await crypto.subtle.decrypt({name:"AES-GCM",iv:h(e)},r,t);return new Uint8Array(i)}catch{return null}}};var m=class s{constructor(t,e,r){this.dirty=!1;this.id=t,this.key=e,this.metadata=r}async serialize(){return await this.key.encryptObject(this.metadata)}handle(t){return{n:t,i:this.id,k:this.key.exportUnsafeRaw()}}static isMetadata(t){return t!==null&&typeof t=="object"&&!Array.isArray(t)&&"f"in t&&typeof t.f=="string"&&"h"in t&&typeof t.h=="string"&&"v"in t&&typeof t.v=="string"}static async deserialize(t,e,r){let i=await e.decryptObject(r);return!i||!s.isMetadata(i)?null:new s(t,e,i)}},p=class s{constructor(t,e,r){this.folders=new Map;this.files=new Map;this.dirty=!1;this.id=t,this.key=e,this.metadata=r??{s:[],f:[]}}async serialize(){return await this.key.encryptObject(this.metadata)}handle(t){return{n:t,i:this.id,k:this.key.exportUnsafeRaw()}}static isMetadata(t){let e=r=>r!==null&&typeof r=="object"&&!Array.isArray(r)&&"n"in r&&typeof r.n=="string"&&"i"in r&&typeof r.i=="number"&&"k"in r&&typeof r.k=="string";return t!==null&&typeof t=="object"&&!Array.isArray(t)&&"s"in t&&Array.isArray(t.s)&&t.s.every(e)&&"f"in t&&Array.isArray(t.f)&&t.f.every(e)}static async deserialize(t,e,r){let i=await e.decryptObject(r);return!i||!s.isMetadata(i)?null:new s(t,e,i)}isFolder(t,e){return!!this.metadata.s.find(({n:r,i})=>r===t&&(typeof e>"u"||i===e))}isFile(t,e){return!!this.metadata.f.find(({n:r,i})=>r===t&&(typeof e>"u"||i===e))}listFolders(){let t=this.metadata.s.map(({n:e})=>e);return t.sort((e,r)=>e.localeCompare(r)),t}listFiles(){let t=this.metadata.f.map(({n:e})=>e);return t.sort((e,r)=>e.localeCompare(r)),t}listDirtyFolders(){let t=[...this.folders.entries()].filter(([e,r])=>r.dirty).map(([e,r])=>e);return t.sort((e,r)=>e.localeCompare(r)),t}listDirtyFiles(){let t=[...this.files.entries()].filter(([e,r])=>r.dirty).map(([e,r])=>e);return t.sort((e,r)=>e.localeCompare(r)),t}async getFolderOrNull(t,e){let r=this.folders.get(t);if(r)return r;let i=this.metadata.s.find(l=>l.n===t);if(!i)return null;let n=u.importUnsafeRaw(i.k),o=await e.readString(`${i.i}.txt`),a=await s.deserialize(i.i,n,o);return a?(this.folders.set(t,a),a):null}async getFolder(t,e){let r=await this.getFolderOrNull(t,e);if(!r)throw new Error(`Folder not found: ${t}`);return r}async getFileOrNull(t,e){let r=this.files.get(t);if(r)return r;let i=this.metadata.f.find(l=>l.n===t);if(!i)return null;let n=u.importUnsafeRaw(i.k),o=await e.readString(`${i.i}.txt`),a=await m.deserialize(i.i,n,o);return a?(this.files.set(t,a),a):null}async getFile(t,e){let r=await this.getFileOrNull(t,e);if(!r)throw new Error(`File not found: ${t}`);return r}async findHash(t,e){for(let r of this.listFiles()){let i=await this.getFile(r,e);if(i.metadata.h===t)return i}for(let r of this.listFolders()){let n=await(await this.getFolder(r,e)).findHash(t,e);if(n)return n}return null}putFolder(t,e){this.deleteFile(t),this.dirty=!0,this.folders.set(t,e);let r=e.handle(t),i=this.metadata.s.findIndex(n=>n.n===t);i>=0?this.metadata.s[i]=r:this.metadata.s.push(r)}deleteFolder(t){let e=this.metadata.s.findIndex(r=>r.n===t);e<0||(this.dirty=!0,this.folders.delete(t),this.metadata.s.splice(e,1))}putFile(t,e){this.deleteFolder(t),this.dirty=!0,this.files.set(t,e);let r=e.handle(t),i=this.metadata.f.findIndex(n=>n.n===t);return i>=0?this.metadata.f[i]=r:this.metadata.f.push(r),this}deleteFile(t){let e=this.metadata.f.findIndex(r=>r.n===t);e<0||(this.dirty=!0,this.files.delete(t),this.metadata.f.splice(e,1))}async maxId(t){let e=this.id;for(let r of this.listFiles()){let i=await this.getFile(r,t);e=Math.max(e,i.id)}for(let r of this.listFolders()){let i=await this.getFolder(r,t);e=Math.max(e,await i.maxId(t))}return e}async findId(t,e){if(this.id===t)return!0;for(let r of this.listFiles())if((await this.getFile(r,e)).id===t)return!0;for(let r of this.listFolders()){let i=await this.getFolder(r,e);if(i.id===t||await i.findId(t,e))return!0}return!1}},v=class s{constructor(t,e,r){this.root=t,this.io=r,this.path=[],this.difficulty=e}static async create(t){let e=await u.generate(),r=new p(-1,e);return r.dirty=!0,new s(r,0,t)}static async deserialize(t,e,r){let i=t.split("~");if(i.length!==2)return null;let n=await u.importWithPassword(i[0],e);if(!n)return null;let{key:o,difficulty:a}=n,l=await p.deserialize(-1,o,i[1]);return l?new s(l,a,r):null}containerDirty(){return this.root.dirty}async serialize(t,e=0){let r=e>0?e:this.difficulty>0?this.difficulty:5;return`${await this.root.key.exportWithPassword(t,r)}~${await this.root.serialize()}`}async save(t=!1){let e=async i=>{await this.io.writeString(`${i.id}.txt`,await i.serialize()),i.dirty=!1},r=async i=>{i.id>=0&&(t||i.dirty)&&(await this.io.writeString(`${i.id}.txt`,await i.serialize()),i.dirty=!1);let n=t?i.listFiles():i.listDirtyFiles();await Promise.all(n.map(a=>i.getFile(a,this.io).then(l=>e(l))));let o=i.listFolders();await Promise.all(o.map(a=>i.getFolder(a,this.io).then(l=>r(l))))};await r(this.root)}currentFolder(){return this.path.length<=0?this.root:this.path[0].folder}getPath(){return`/${this.path.map(({name:t})=>t).reverse().join("/")}`}async setPath(t){let e=this.path.map(({name:n})=>n).reverse(),r=g(`/${e.join("/")}`,t),i=0;for(;i<e.length&&i<r.length&&e[i]===r[i];i++);for(;e.length>i;)e.pop(),this.exitFolder();for(;i<r.length;i++)await this.enterFolder(r[i])}listFolders(){return this.currentFolder().listFolders()}listFiles(){return this.currentFolder().listFiles()}async enterFolder(t){let e=await this.currentFolder().getFolder(t,this.io);this.path.unshift({name:t,folder:e})}exitFolder(){this.path.shift()}exitToRoot(){this.path=[]}async putFile(t,e){if(t.indexOf("/")>=0||t==="."||t==="..")throw new Error(`Invalid file name: ${t}`);let r=await k(e),i=await this.root.findHash(r,this.io);if(i)return this.currentFolder().isFile(t,i.id)?"exists":(this.currentFolder().putFile(t,i),"linked");let n=1+await this.root.maxId(this.io),o=await u.generate(),a=`file-${crypto.randomUUID()}.bin`,{encryptedBytes:l,iv:d}=await o.encryptBytes(e),c=new m(n,o,{f:a,h:r,v:d});return c.dirty=!0,this.currentFolder().putFile(t,c),await this.io.write(a,l),"success"}async putFileLink(t,e,r){if(t.indexOf("/")>=0||t==="."||t==="..")throw new Error(`Invalid file name: ${t}`);let i=r??this,n=g(i.getPath(),e);if(n.length<=0)throw new Error(`Invalid source file: ${t}`);let o=i.root;for(let l=0;l<n.length-1;l++)o=await o.getFolder(n[l],this.io);let a=await o.getFile(n[n.length-1],this.io);return this.currentFolder().isFile(t,a.id)?"exists":(this.currentFolder().putFile(t,a),"linked")}async putFolder(t){if(t.indexOf("/")>=0||t==="."||t==="..")throw new Error(`Invalid folder name: ${t}`);if(this.currentFolder().isFolder(t))return"exists";let e=1+await this.root.maxId(this.io),r=await u.generate(),i=new p(e,r);return i.dirty=!0,this.currentFolder().putFolder(t,i),"success"}async putFolderLink(t,e,r){if(t.indexOf("/")>=0||t==="."||t==="..")throw new Error(`Invalid folder name: ${t}`);let i=r??this,n=g(i.getPath(),e),o=i.root;for(let a=0;a<n.length;a++)o=await o.getFolder(n[a],this.io);return this.currentFolder().isFolder(t,o.id)?"exists":(this.currentFolder().putFolder(t,o),"linked")}async getFile(t){let e=await this.currentFolder().getFileOrNull(t,this.io);if(!e)return null;let r=await this.io.read(e.metadata.f),i=await e.key.decryptBytes(r,e.metadata.v);return i||null}async remove(t){let e=async(a,l,d)=>(a.deleteFile(l),await this.root.findId(d.id,this.io)?"unlinked-file":(await this.io.remove(d.metadata.f),await this.io.remove(`${d.id}.txt`),"removed-file")),r=async(a,l,d)=>{for(let c of d.listFolders()){let F=await d.getFolder(c,this.io);await r(d,c,F)}for(let c of d.listFiles()){let F=await d.getFile(c,this.io);await e(d,c,F)}return a.deleteFolder(l),await this.root.findId(d.id,this.io)?"unlinked-folder":(await this.io.remove(`${d.id}.txt`),"removed-folder")},i=this.currentFolder(),n=await i.getFileOrNull(t,this.io);if(n)return e(i,t,n);let o=await i.getFolderOrNull(t,this.io);return o?r(i,t,o):"notfound"}};var f=class{async readString(t){let e=await this.read(t);return new TextDecoder().decode(e)}async writeString(t,e){await this.write(t,new TextEncoder().encode(e))}},P=class extends f{constructor(){super(...arguments);this.files=new Map}async remove(e){this.files.delete(e)}async read(e){let r=this.files.get(e);if(!r)throw new Error(`File not found: ${e}`);return r}async write(e,r){this.files.set(e,r)}},A=class extends f{constructor(e,r){super();this.cache=new Map;this.maxFiles=e,this.io=r}update(e,r){if(this.cache.set(e,{data:r,lastUsed:Date.now()}),this.cache.size>this.maxFiles){let i="",n=Date.now();for(let[o,a]of this.cache)a.lastUsed<n&&(i=o,n=a.lastUsed);this.cache.delete(i)}}async remove(e){await this.io.remove(e),this.cache.delete(e)}async read(e){let r=this.cache.get(e);if(r)return r.lastUsed=Date.now(),r.data;let i=await this.io.read(e);return this.update(e,i),i}async readString(e){let r=this.cache.get(e);if(r)return r.lastUsed=Date.now(),new TextDecoder().decode(r.data);let i=await this.io.readString(e);return this.update(e,new TextEncoder().encode(i)),i}async write(e,r){await this.io.write(e,r),this.update(e,r)}async writeString(e,r){await this.io.writeString(e,r),this.update(e,new TextEncoder().encode(r))}},b=class extends f{constructor(t,e,r="/"){super(),this.rootDir=t,this.io=e,this.separator=r}remove(t){return this.io.remove(`${this.rootDir}${this.separator}${t}`)}read(t){return this.io.read(`${this.rootDir}${this.separator}${t}`)}readString(t){return this.io.readString(`${this.rootDir}${this.separator}${t}`)}write(t,e){return this.io.write(`${this.rootDir}${this.separator}${t}`,e)}writeString(t,e){return this.io.writeString(`${this.rootDir}${this.separator}${t}`,e)}},U=class extends f{constructor(t){super(),this.io=t}remove(t){throw new Error("Cannot remove in read-only mode")}read(t){return this.io.read(t)}readString(t){return this.io.readString(t)}write(t,e){throw new Error("Cannot write in read-only mode")}writeString(t,e){throw new Error("Cannot write in read-only mode")}};var S=class extends f{async remove(t){throw new Error("Cannot remove files in browser")}async read(t){let r=await(await fetch(t,{cache:"no-store"})).arrayBuffer();return new Uint8Array(r)}async readString(t){return await(await fetch(t,{cache:"no-store"})).text()}async write(t,e){throw new Error("Cannot write bytes in browser")}};return C(K);})();
