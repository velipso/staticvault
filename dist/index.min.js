"use strict";var StaticVault=(()=>{var x=Object.defineProperty;var E=Object.getOwnPropertyDescriptor;var V=Object.getOwnPropertyNames;var M=Object.prototype.hasOwnProperty;var C=(a,t)=>{for(var e in t)x(a,e,{get:t[e],enumerable:!0})},O=(a,t,e,r)=>{if(t&&typeof t=="object"||typeof t=="function")for(let i of V(t))!M.call(a,i)&&i!==e&&x(a,i,{get:()=>t[i],enumerable:!(r=E(t,i))||r.enumerable});return a};var K=a=>O(x({},"__esModule",{value:!0}),a);var D={};C(D,{BrowserFileIO:()=>S,CacheFileIO:()=>b,CryptoKey:()=>u,DirectoryFileIO:()=>U,FileIO:()=>w,MemoryFileIO:()=>A,ReadonlyFileIO:()=>I,Vault:()=>P,bytesToString:()=>h,hashBytes:()=>v,resolvePath:()=>g,stringToBytes:()=>f,stringify:()=>F});function h(a){return(typeof process<"u"?Buffer.from(a).toString("base64"):btoa(String.fromCharCode(...a))).replace(/\+/g,"-").replace(/\//g,"_").replace(/=+$/,"")}function f(a){let t=a.replace(/-/g,"+").replace(/_/g,"/");for(;t.length%4;)t+="=";return typeof process<"u"?new Uint8Array(Buffer.from(t,"base64")):new Uint8Array(atob(t).split("").map(e=>e.charCodeAt(0)))}function F(a){if(a!==null&&typeof a=="object"&&!Array.isArray(a)){let t=Object.keys(a);t.sort((r,i)=>r.localeCompare(i));let e=[];for(let r of t)e.push(`${JSON.stringify(r)}:${F(a[r])}`);return`{${e.join(",")}}`}else return JSON.stringify(a)}async function v(a){let t=await crypto.subtle.digest("SHA-256",a);return Array.from(new Uint8Array(t)).map(e=>e.toString(16).padStart(2,"0")).join("")}function g(a,t){if(!a.startsWith("/"))throw new Error("Current directory must be absolute");let e=t.startsWith("/")||a==="/"?[]:a.substr(1).split("/"),r=t.split("/");for(let i of r)i==="."||(i===".."?e.pop():i!==""&&e.push(i));return e}var u=class a{constructor(t){this.key=t}assertEqual(t){if(!t||this.key.length!==t.key.length)throw new Error("Keys not equal");for(let e=0;e<this.key.length;e++)if(this.key[e]!==t.key[e])throw new Error("Keys not equal")}static async generate(){let t=await crypto.subtle.generateKey({name:"AES-GCM",length:256},!0,["encrypt","decrypt"]),e=await crypto.subtle.exportKey("raw",t);return new a(new Uint8Array(e))}static importUnsafeRaw(t){return new a(f(t))}static async importWithPassword(t,e){let r=t.split(".");if(r.length!==4)return null;let i=parseFloat(r[3]);if(isNaN(i)||i<=0||Math.floor(i)!==i)return null;try{let[n,c,o]=r,s=await crypto.subtle.importKey("raw",new TextEncoder().encode(e),{name:"PBKDF2"},!1,["deriveKey"]),l=await crypto.subtle.deriveKey({name:"PBKDF2",salt:f(c),iterations:i*1e5,hash:"SHA-256"},s,{name:"AES-GCM",length:256},!1,["decrypt"]),d=await crypto.subtle.decrypt({name:"AES-GCM",iv:f(o)},l,f(n));return{key:new a(new Uint8Array(d)),difficulty:i}}catch{return null}}exportUnsafeRaw(){return h(this.key)}async exportWithPassword(t,e=5){if(isNaN(e)||e<=0||Math.floor(e)!==e)throw new Error("Invalid difficulty");let r=new TextEncoder,i=crypto.getRandomValues(new Uint8Array(16)),n=crypto.getRandomValues(new Uint8Array(12)),c=await crypto.subtle.importKey("raw",r.encode(t),{name:"PBKDF2"},!1,["deriveKey"]),o=await crypto.subtle.deriveKey({name:"PBKDF2",salt:i,iterations:e*1e5,hash:"SHA-256"},c,{name:"AES-GCM",length:256},!1,["encrypt"]),s=await crypto.subtle.encrypt({name:"AES-GCM",iv:n},o,this.key);return[h(new Uint8Array(s)),h(i),h(n),`${e}`].join(".")}async encryptString(t){let e=crypto.getRandomValues(new Uint8Array(12)),r=await crypto.subtle.importKey("raw",this.key,{name:"AES-GCM"},!1,["encrypt"]),i=await crypto.subtle.encrypt({name:"AES-GCM",iv:e},r,new TextEncoder().encode(t));return[h(new Uint8Array(i)),h(e)].join(".")}async decryptString(t){let e=t.split(".");if(e.length!==2)return null;try{let[r,i]=e,n=await crypto.subtle.importKey("raw",this.key,{name:"AES-GCM"},!1,["decrypt"]),c=await crypto.subtle.decrypt({name:"AES-GCM",iv:f(i)},n,f(r));return new TextDecoder().decode(c)}catch{return null}}async encryptObject(t){return"b"+await this.encryptString(F(t))}async decryptObject(t){try{let e=await this.decryptString(t.substr(1));if(!e)return null;let r=JSON.parse(e);return r&&typeof r=="object"?r:null}catch{return null}}async encryptBytes(t){let e=crypto.getRandomValues(new Uint8Array(12)),r=await crypto.subtle.importKey("raw",this.key,{name:"AES-GCM"},!1,["encrypt"]),i=await crypto.subtle.encrypt({name:"AES-GCM",iv:e},r,t);return{encryptedBytes:new Uint8Array(i),iv:h(e)}}async decryptBytes(t,e){try{let r=await crypto.subtle.importKey("raw",this.key,{name:"AES-GCM"},!1,["decrypt"]),i=await crypto.subtle.decrypt({name:"AES-GCM",iv:f(e)},r,t);return new Uint8Array(i)}catch{return null}}};var k=class a{constructor(t,e,r){this.dirty=!1;this.id=t,this.key=e,this.metadata=r}async serialize(){return await this.key.encryptObject(this.metadata)}handle(t){return{n:t,i:this.id,k:this.key.exportUnsafeRaw()}}static isMetadata(t){return t!==null&&typeof t=="object"&&!Array.isArray(t)&&"f"in t&&typeof t.f=="string"&&"h"in t&&typeof t.h=="string"&&"j"in t&&typeof t.j=="string"&&"v"in t&&typeof t.v=="string"}static async deserialize(t,e,r){let i=await e.decryptObject(r);return!i||!a.isMetadata(i)?null:new a(t,e,i)}},p=class a{constructor(t,e,r){this.folders=new Map;this.files=new Map;this.dirty=!1;this.id=t,this.key=e,this.metadata=r??{s:[],f:[]}}async serialize(t){return await this.key.encryptObject(t?{...t,...this.metadata}:this.metadata)}handle(t){return{n:t,i:this.id,k:this.key.exportUnsafeRaw()}}static isMetadata(t){let e=r=>r!==null&&typeof r=="object"&&!Array.isArray(r)&&"n"in r&&typeof r.n=="string"&&"i"in r&&typeof r.i=="number"&&"k"in r&&typeof r.k=="string";return t!==null&&typeof t=="object"&&!Array.isArray(t)&&"s"in t&&Array.isArray(t.s)&&t.s.every(e)&&"f"in t&&Array.isArray(t.f)&&t.f.every(e)}static async deserialize(t,e,r){let i=await e.decryptObject(r);return!i||!a.isMetadata(i)?null:new a(t,e,i)}isFolder(t,e){return!!this.metadata.s.find(({n:r,i})=>r===t&&(typeof e>"u"||i===e))}isFile(t,e){return!!this.metadata.f.find(({n:r,i})=>r===t&&(typeof e>"u"||i===e))}listFolders(){let t=this.metadata.s.map(({n:e})=>e);return t.sort((e,r)=>e.localeCompare(r)),t}listFiles(){let t=this.metadata.f.map(({n:e})=>e);return t.sort((e,r)=>e.localeCompare(r)),t}listDirtyFolders(){let t=[...this.folders.entries()].filter(([e,r])=>r.dirty).map(([e,r])=>e);return t.sort((e,r)=>e.localeCompare(r)),t}listDirtyFiles(){let t=[...this.files.entries()].filter(([e,r])=>r.dirty).map(([e,r])=>e);return t.sort((e,r)=>e.localeCompare(r)),t}async getFolderOrNull(t,e){let r=this.folders.get(t);if(r)return r;let i=this.metadata.s.find(s=>s.n===t);if(!i)return null;let n=u.importUnsafeRaw(i.k),c=await e.readString(`${i.i}.txt`),o=await a.deserialize(i.i,n,c);return o?(this.folders.set(t,o),o):null}async getFolder(t,e){let r=await this.getFolderOrNull(t,e);if(!r)throw new Error(`Folder not found: ${t}`);return r}async getFileOrNull(t,e){let r=this.files.get(t);if(r)return r;let i=this.metadata.f.find(s=>s.n===t);if(!i)return null;let n=u.importUnsafeRaw(i.k),c=await e.readString(`${i.i}.txt`),o=await k.deserialize(i.i,n,c);return o?(this.files.set(t,o),o):null}async getFile(t,e){let r=await this.getFileOrNull(t,e);if(!r)throw new Error(`File not found: ${t}`);return r}async findHash(t,e){for(let r of this.listFiles()){let i=await this.getFile(r,e);if(i.metadata.h===t)return i}for(let r of this.listFolders()){let n=await(await this.getFolder(r,e)).findHash(t,e);if(n)return n}return null}putFolder(t,e){this.deleteFile(t),this.dirty=!0,this.folders.set(t,e);let r=e.handle(t),i=this.metadata.s.findIndex(n=>n.n===t);i>=0?this.metadata.s[i]=r:this.metadata.s.push(r)}deleteFolder(t){let e=this.metadata.s.findIndex(r=>r.n===t);e<0||(this.dirty=!0,this.folders.delete(t),this.metadata.s.splice(e,1))}putFile(t,e){this.deleteFolder(t),this.dirty=!0,this.files.set(t,e);let r=e.handle(t),i=this.metadata.f.findIndex(n=>n.n===t);return i>=0?this.metadata.f[i]=r:this.metadata.f.push(r),this}deleteFile(t){let e=this.metadata.f.findIndex(r=>r.n===t);e<0||(this.dirty=!0,this.files.delete(t),this.metadata.f.splice(e,1))}async maxId(t){let e=this.id;for(let r of this.listFiles()){let i=await this.getFile(r,t);e=Math.max(e,i.id)}for(let r of this.listFolders()){let i=await this.getFolder(r,t);e=Math.max(e,await i.maxId(t))}return e}async findId(t,e){if(this.id===t)return!0;for(let r of this.listFiles())if((await this.getFile(r,e)).id===t)return!0;for(let r of this.listFolders()){let i=await this.getFolder(r,e);if(i.id===t||await i.findId(t,e))return!0}return!1}},P=class a{static{this.DEFAULT_DIFFICULTY=5}static{this.ROOT_FILE="staticvault.txt"}constructor(t,e,r){this.root=t,this.io=r,this.path=[],this.difficulty=e}static async create(t){let e=await u.generate(),r=new p(-1,e);return r.dirty=!0,new a(r,0,t)}static async deserialize(t,e,r){let i=t.split("~");if(i.length!==2)return null;let n=await u.importWithPassword(i[0],e);if(!n)return null;let{key:c,difficulty:o}=n,s=await p.deserialize(-1,c,i[1]);if(!s)return null;let l=s.metadata;return"x"in l&&typeof l.x=="number"&&Math.floor(Date.now()/6e4)>=l.x?null:new a(s,o,r)}containerDirty(){return this.root.dirty}async serialize(t,e=0,r=0){let i=e>0?e:this.difficulty>0?this.difficulty:a.DEFAULT_DIFFICULTY,n;r>0&&(n={x:Math.ceil(Date.now()/6e4)+r});let c=await this.root.key.exportWithPassword(t,i),o=await this.root.serialize(n);return`${c}~${o}`}async save(t=!1){let e=async i=>{await this.io.writeString(`${i.id}.txt`,await i.serialize()),i.dirty=!1},r=async i=>{i.id>=0&&(t||i.dirty)&&(await this.io.writeString(`${i.id}.txt`,await i.serialize()),i.dirty=!1);let n=t?i.listFiles():i.listDirtyFiles();await Promise.all(n.map(o=>i.getFile(o,this.io).then(s=>e(s))));let c=i.listFolders();await Promise.all(c.map(o=>i.getFolder(o,this.io).then(s=>r(s))))};await r(this.root)}async rekey(t=!1,e=!1){let r=new Map,i=new Map,n=async(o,s)=>{if(e||console.log(o),s.key=await u.generate(),s.dirty=!0,r.set(s.id,s),t){let l=u.importUnsafeRaw(s.metadata.j),d=await this.io.read(s.metadata.f),y=await l.decryptBytes(d,s.metadata.v);if(!y){e||console.warn(`Warning: Failed to decrypt file: ${o} (${s.metadata.f})`);return}l=await u.generate();let{encryptedBytes:m,iv:$}=await l.encryptBytes(y);s.metadata.j=l.exportUnsafeRaw(),s.metadata.v=$,await this.io.write(s.metadata.f,m)}},c=async(o,s)=>{!e&&o&&console.log(o),s.key=await u.generate(),s.dirty=!0,i.set(s.id,s);for(let l of s.listFolders()){let d=await s.getFolder(l,this.io),y=i.get(d.id);s.deleteFolder(l),y?s.putFolder(l,y):(await c(`${o}/${l}`,d),s.putFolder(l,d))}for(let l of s.listFiles()){let d=await s.getFile(l,this.io),y=r.get(d.id);s.deleteFile(l),y?s.putFile(l,y):(await n(`${o}/${l}`,d),s.putFile(l,d))}};await c("",this.root)}currentFolder(){return this.path.length<=0?this.root:this.path[0].folder}getPath(){return`/${this.path.map(({name:t})=>t).reverse().join("/")}`}async setPath(t){let e=this.path.map(({name:n})=>n).reverse(),r=g(`/${e.join("/")}`,t),i=0;for(;i<e.length&&i<r.length&&e[i]===r[i];i++);for(;e.length>i;)e.pop(),this.exitFolder();for(;i<r.length;i++)await this.enterFolder(r[i])}listFolders(){return this.currentFolder().listFolders()}listFiles(){return this.currentFolder().listFiles()}async enterFolder(t){let e=await this.currentFolder().getFolder(t,this.io);this.path.unshift({name:t,folder:e})}exitFolder(){this.path.shift()}exitToRoot(){this.path=[]}async putFile(t,e){if(t.indexOf("/")>=0||t==="."||t==="..")throw new Error(`Invalid file name: ${t}`);let r=await v(e),i=await this.root.findHash(r,this.io);if(i)return this.currentFolder().isFile(t,i.id)?"exists":(this.currentFolder().putFile(t,i),"linked");let n=1+await this.root.maxId(this.io),[c,o]=await Promise.all([u.generate(),u.generate()]),s=o.exportUnsafeRaw(),l=`file-${crypto.randomUUID()}.bin`,{encryptedBytes:d,iv:y}=await o.encryptBytes(e),m=new k(n,c,{f:l,h:r,j:s,v:y});return m.dirty=!0,this.currentFolder().putFile(t,m),await this.io.write(l,d),"success"}async putFileLink(t,e,r){if(t.indexOf("/")>=0||t==="."||t==="..")throw new Error(`Invalid file name: ${t}`);let i=r??this,n=g(i.getPath(),e);if(n.length<=0)throw new Error(`Invalid source file: ${t}`);let c=i.root;for(let s=0;s<n.length-1;s++)c=await c.getFolder(n[s],this.io);let o=await c.getFile(n[n.length-1],this.io);return this.currentFolder().isFile(t,o.id)?"exists":(this.currentFolder().putFile(t,o),"linked")}async putFolder(t){if(t.indexOf("/")>=0||t==="."||t==="..")throw new Error(`Invalid folder name: ${t}`);if(this.currentFolder().isFolder(t))return"exists";let e=1+await this.root.maxId(this.io),r=await u.generate(),i=new p(e,r);return i.dirty=!0,this.currentFolder().putFolder(t,i),"success"}async putFolderLink(t,e,r){if(t.indexOf("/")>=0||t==="."||t==="..")throw new Error(`Invalid folder name: ${t}`);let i=r??this,n=g(i.getPath(),e),c=i.root;for(let o=0;o<n.length;o++)c=await c.getFolder(n[o],this.io);return this.currentFolder().isFolder(t,c.id)?"exists":(this.currentFolder().putFolder(t,c),"linked")}async getFile(t){let e=await this.currentFolder().getFileOrNull(t,this.io);if(!e)return null;let r=await this.io.read(e.metadata.f),n=await u.importUnsafeRaw(e.metadata.j).decryptBytes(r,e.metadata.v);return n||null}async remove(t){let e=async(o,s,l)=>(o.deleteFile(s),await this.root.findId(l.id,this.io)?"unlinked-file":(await this.io.remove(l.metadata.f),await this.io.remove(`${l.id}.txt`),"removed-file")),r=async(o,s,l)=>{for(let d of l.listFolders()){let y=await l.getFolder(d,this.io);await r(l,d,y)}for(let d of l.listFiles()){let y=await l.getFile(d,this.io);await e(l,d,y)}return o.deleteFolder(s),await this.root.findId(l.id,this.io)?"unlinked-folder":(await this.io.remove(`${l.id}.txt`),"removed-folder")},i=this.currentFolder(),n=await i.getFileOrNull(t,this.io);if(n)return e(i,t,n);let c=await i.getFolderOrNull(t,this.io);return c?r(i,t,c):"notfound"}};var w=class{async readString(t){let e=await this.read(t);return new TextDecoder().decode(e)}async writeString(t,e){await this.write(t,new TextEncoder().encode(e))}},A=class extends w{constructor(){super(...arguments);this.files=new Map}async remove(e){this.files.delete(e)}async read(e){let r=this.files.get(e);if(!r)throw new Error(`File not found: ${e}`);return r}async write(e,r){this.files.set(e,r)}},b=class extends w{constructor(e,r){super();this.cache=new Map;this.maxFiles=e,this.io=r}update(e,r){if(this.cache.set(e,{data:r,lastUsed:Date.now()}),this.cache.size>this.maxFiles){let i="",n=Date.now();for(let[c,o]of this.cache)o.lastUsed<n&&(i=c,n=o.lastUsed);this.cache.delete(i)}}async remove(e){await this.io.remove(e),this.cache.delete(e)}async read(e){let r=this.cache.get(e);if(r)return r.lastUsed=Date.now(),r.data;let i=await this.io.read(e);return this.update(e,i),i}async readString(e){let r=this.cache.get(e);if(r)return r.lastUsed=Date.now(),new TextDecoder().decode(r.data);let i=await this.io.readString(e);return this.update(e,new TextEncoder().encode(i)),i}async write(e,r){await this.io.write(e,r),this.update(e,r)}async writeString(e,r){await this.io.writeString(e,r),this.update(e,new TextEncoder().encode(r))}},U=class extends w{constructor(t,e,r="/"){super(),this.rootDir=t,this.io=e,this.separator=r}remove(t){return this.io.remove(`${this.rootDir}${this.separator}${t}`)}read(t){return this.io.read(`${this.rootDir}${this.separator}${t}`)}readString(t){return this.io.readString(`${this.rootDir}${this.separator}${t}`)}write(t,e){return this.io.write(`${this.rootDir}${this.separator}${t}`,e)}writeString(t,e){return this.io.writeString(`${this.rootDir}${this.separator}${t}`,e)}},I=class extends w{constructor(t){super(),this.io=t}remove(t){throw new Error("Cannot remove in read-only mode")}read(t){return this.io.read(t)}readString(t){return this.io.readString(t)}write(t,e){throw new Error("Cannot write in read-only mode")}writeString(t,e){throw new Error("Cannot write in read-only mode")}};var S=class extends w{async remove(t){throw new Error("Cannot remove files in browser")}async read(t){let r=await(await fetch(t,{cache:"no-store"})).arrayBuffer();return new Uint8Array(r)}async readString(t){return await(await fetch(t,{cache:"no-store"})).text()}async write(t,e){throw new Error("Cannot write bytes in browser")}};return K(D);})();
